<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elevator Simulator</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Load Babel for JSX support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONS (Inline SVGs to replace lucide-react for standalone usage) ---
        const Play = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        );
        const Pause = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
        );
        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        );
        const Building = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="9" y1="22" x2="9" y2="22.01"></line><line x1="15" y1="22" x2="15" y2="22.01"></line><line x1="12" y1="22" x2="12" y2="22.01"></line><line x1="12" y1="2" x2="12" y2="22"></line><line x1="4" y1="10" x2="20" y2="10"></line><line x1="4" y1="14" x2="20" y2="14"></line><line x1="4" y1="18" x2="20" y2="18"></line><line x1="4" y1="6" x2="20" y2="6"></line></svg>
        );
        const Settings = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
        );
        const ArrowUp = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>
        );
        const ArrowDown = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>
        );
        const Activity = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
        );

        // --- CONSTANTS & CONFIG ---
        const FLOOR_HEIGHT_PX = 40;
        const LIFT_CAPACITY = 12; 
        const TIME_STEP = 0.05; // 1 tick = 3 seconds
        const LIFT_SPEED_FLOORS_PER_TICK = 0.1; 
        const DOOR_TIME_TICKS = 10; 

        // --- PURE LOGIC FUNCTIONS ---
        const getTrafficProbability = (type, timeMinutes, isGround) => {
          const hour = timeMinutes / 60;
          
          if (type === 'residential') {
            if (isGround) {
              if (hour >= 16 && hour <= 20) return 0.0045; 
              if (hour > 20) return 0.0005;
              return 0.0001;
            } else {
              if (hour >= 6.5 && hour <= 9.5) return 0.006;
              if (hour >= 11 && hour <= 14) return 0.001;
              return 0.0001;
            }
          } else {
            if (isGround) {
              if (hour >= 7.5 && hour <= 9.5) return 0.009;
              if (hour >= 13 && hour <= 14) return 0.008;
              return 0.0005;
            } else {
              if (hour >= 16.5 && hour <= 19) return 0.007;
              if (hour >= 12 && hour <= 13) return 0.008;
              return 0.0005;
            }
          }
        };

        const determineDestination = (currentFloor, type, totalFloors) => {
          if (currentFloor === 0) {
            return Math.floor(Math.random() * (totalFloors - 1)) + 1;
          }
          if (type === 'residential') {
            return Math.random() < 0.9 ? 0 : Math.floor(Math.random() * totalFloors);
          } else {
            return Math.random() < 0.8 ? 0 : Math.floor(Math.random() * totalFloors);
          }
        };

        // Extracted Pure Reducer for Sub-stepping
        const calculateNextState = (prevState, config) => {
          let { time, lifts, passengers, stats } = prevState;
          const { floors, avgResidentsPerFloor, buildingType, idleAlgo } = config;

          // 1. ADVANCE TIME
          const newTime = time + TIME_STEP;
          if (newTime >= 1440) return { ...prevState, isRunning: false };

          // 2. SPAWN PASSENGERS
          let newPassengers = [...passengers];
          for (let f = 0; f < floors; f++) {
            const population = f === 0 ? avgResidentsPerFloor * floors : avgResidentsPerFloor; 
            const probPerMinute = getTrafficProbability(buildingType, newTime, f === 0);
            const spawnProb = probPerMinute * TIME_STEP; 
            
            if (Math.random() < spawnProb * population) {
              const dest = determineDestination(f, buildingType, floors);
              if (dest !== f) {
                newPassengers.push({
                  id: Math.random().toString(36).substr(2, 9),
                  from: f,
                  to: dest,
                  spawnTime: newTime,
                  state: 'WAITING',
                });
              }
            }
          }

          // 3. LIFT LOGIC
          let newLifts = lifts.map(lift => {
            let l = { ...lift };
            const currentFloorInt = Math.round(l.floor);

            if (l.state === 'DOOR_OPEN') {
                l.timer--;
                if (l.timer <= 0) {
                    l.state = 'DOOR_CLOSE'; 
                    l.timer = DOOR_TIME_TICKS / 2;
                }
            } else if (l.state === 'DOOR_CLOSE') {
                l.timer--;
                if (l.timer <= 0) {
                    l.state = l.passengers.length > 0 || l.targetFloor !== null ? 'MOVING' : 'IDLE';
                    if (l.targetFloor !== null && l.targetFloor !== currentFloorInt) {
                         l.direction = l.targetFloor > currentFloorInt ? 1 : -1;
                    } else if (l.passengers.length > 0) {
                         l.direction = l.passengers[0].to > currentFloorInt ? 1 : -1;
                    } else {
                         l.direction = 0;
                    }
                }
            } else if (l.state === 'MOVING') {
                if (l.targetFloor !== null) {
                    const dist = l.targetFloor - l.floor;
                    const moveStep = Math.min(Math.abs(dist), LIFT_SPEED_FLOORS_PER_TICK);
                    l.floor += Math.sign(dist) * moveStep;

                    if (Math.abs(l.floor - l.targetFloor) < 0.01) { 
                        l.floor = l.targetFloor;
                        l.state = 'DOOR_OPEN';
                        l.timer = DOOR_TIME_TICKS;
                        l.targetFloor = null; 
                    }
                } else {
                    l.state = 'IDLE';
                }
            } else if (l.state === 'IDLE') {
                if (Math.abs(l.floor - Math.round(l.floor)) > 0.05) {
                    l.targetFloor = Math.round(l.floor);
                    l.state = 'MOVING';
                }
            }

            return l;
          });

          // 4. DISPATCHER & BOARDING 
          
          // A. Unload
          newLifts.forEach(l => {
            if (l.state === 'DOOR_OPEN') {
               const staying = [];
               l.passengers.forEach(p => {
                   if (p.to === Math.round(l.floor)) {
                       stats.delivered++;
                       const waitTime = p.boardTime - p.spawnTime; 
                       stats.totalWaitTime += waitTime;
                       stats.maxWaitTime = Math.max(stats.maxWaitTime, waitTime);
                   } else {
                       staying.push(p);
                   }
               });
               l.passengers = staying;
            }
          });

          // B. Load
          newLifts.forEach(l => {
              if (l.state === 'DOOR_OPEN' && l.passengers.length < LIFT_CAPACITY) {
                  const floor = Math.round(l.floor);
                  const waitingHere = newPassengers.filter(p => p.state === 'WAITING' && p.from === floor);
                  
                  waitingHere.forEach(p => {
                      if (l.passengers.length < LIFT_CAPACITY) {
                          const liftDir = l.direction;
                          const myDir = p.to > floor ? 1 : -1;
                          if (liftDir === 0 || liftDir === myDir) {
                              l.passengers.push({ ...p, boardTime: newTime });
                              const idx = newPassengers.findIndex(np => np.id === p.id);
                              if(idx > -1) newPassengers.splice(idx, 1);
                              if (l.direction === 0) l.direction = myDir;
                          }
                      }
                  });
              }
          });

          // C. Target Assignment
          newLifts.forEach(l => {
              const currentFloor = Math.round(l.floor);
              
              // 1. Existing Passengers (Override)
              if (l.passengers.length > 0) {
                  const destinations = l.passengers.map(p => p.to);
                  if (l.direction === 1) {
                      const above = destinations.filter(d => d > currentFloor).sort((a,b) => a-b);
                      l.targetFloor = above.length > 0 ? above[0] : destinations.sort((a,b) => b-a)[0]; 
                  } else {
                      const below = destinations.filter(d => d < currentFloor).sort((a,b) => b-a);
                      l.targetFloor = below.length > 0 ? below[0] : destinations.sort((a,b) => a-b)[0]; 
                  }
                  if (l.state === 'IDLE') l.state = 'MOVING';
              } 
              // 2. Calls (Smart Weighted Dispatch)
              else {
                  const calls = newPassengers.filter(p => p.state === 'WAITING');
                  if (calls.length > 0 && l.state === 'IDLE') {
                     let bestCall = null;
                     let minCost = Infinity;

                     calls.forEach(call => {
                         const dist = Math.abs(call.from - currentFloor);
                         const waitDuration = newTime - call.spawnTime;
                         
                         const isCovered = lifts.some(other => 
                            other.id !== l.id && 
                            (other.targetFloor === call.from || (Math.round(other.floor) === call.from && other.state !== 'IDLE'))
                         );

                         const cost = dist - (waitDuration * 4) + (isCovered ? 200 : 0);
                         
                         if (cost < minCost) {
                             minCost = cost;
                             bestCall = call;
                         }
                     });

                     if (bestCall) {
                         l.targetFloor = bestCall.from;
                         l.state = 'MOVING';
                     }
                  } 
                  // 3. Idle Logic
                  else if (l.state === 'IDLE' && calls.length === 0) {
                      if (Math.abs(l.floor - currentFloor) < 0.05) {
                          if (idleAlgo === 'return_ground' && currentFloor !== 0) { 
                              l.targetFloor = 0; l.state = 'MOVING'; 
                          } else if (idleAlgo === 'return_dist' && currentFloor !== l.assignedReturn) {
                               l.targetFloor = l.assignedReturn; l.state = 'MOVING'; 
                          } else if (idleAlgo === 'ai') {
                              let hotFloor = -1;
                              const hour = newTime / 60;
                              
                              if (buildingType === 'residential') {
                                  if (hour > 16 && hour < 20) hotFloor = 0; 
                              } else {
                                  if (hour > 7 && hour < 10) hotFloor = 0; 
                                  if (hour > 16 && hour < 19) hotFloor = Math.floor(floors * 0.7); 
                              }

                              if (hotFloor !== -1 && currentFloor !== hotFloor) {
                                  l.targetFloor = hotFloor;
                                  l.state = 'MOVING';
                              }
                          }
                      }
                  }
              }
          });

          return {
            ...prevState,
            time: newTime,
            lifts: newLifts,
            passengers: newPassengers,
            stats
          };
        };

        function ElevatorSimulator() {
          // --- STATE ---
          const [config, setConfig] = useState({
            buildingType: 'residential',
            floors: 10,
            lifts: 3,
            avgResidentsPerFloor: 30,
            idleAlgo: 'stay',
          });

          const configRef = useRef(config);
          useEffect(() => { configRef.current = config; }, [config]);

          const [simState, setSimState] = useState({
            time: 360, 
            isRunning: false,
            speedMultiplier: 100, // DEFAULT 100
            lifts: [],
            passengers: [], 
            stats: {
              totalTrips: 0,
              totalWaitTime: 0,
              maxWaitTime: 0,
              delivered: 0,
            }
          });

          const animationRef = useRef();

          // --- INITIALIZATION ---
          const initSimulation = useCallback(() => {
            const { floors, lifts, idleAlgo } = configRef.current; 
            const newLifts = Array.from({ length: lifts }, (_, i) => ({
              id: i,
              floor: 0, 
              targetFloor: null, 
              state: 'IDLE', 
              passengers: [],
              direction: 0, 
              timer: 0,
              assignedReturn: idleAlgo === 'return_dist' ? 
                Math.floor((floors - 1) * (i / Math.max(1, lifts - 1))) : 0
            }));

            setSimState({
              time: 360, 
              isRunning: false,
              speedMultiplier: 100, // Reset to 100
              lifts: newLifts,
              passengers: [],
              stats: { totalTrips: 0, totalWaitTime: 0, maxWaitTime: 0, delivered: 0 }
            });
          }, []);

          useEffect(() => {
            initSimulation();
          }, []); 

          // --- ANIMATION LOOP (Physics Engine) ---
          useEffect(() => {
            if (simState.isRunning) {
              const loop = () => {
                if (!simState.isRunning) return;

                setSimState(prev => {
                   const ticksPerFrame = (simState.speedMultiplier * 0.016) / (TIME_STEP * 60); 
                   let currentState = prev;
                   const iterations = Math.max(1, Math.floor(simState.speedMultiplier / 50));
                   
                   for(let i=0; i < iterations; i++) {
                      if (currentState.isRunning) {
                         currentState = calculateNextState(currentState, configRef.current);
                      }
                   }
                   
                   return currentState;
                });

                animationRef.current = requestAnimationFrame(loop);
              };
              animationRef.current = requestAnimationFrame(loop);
            } else {
              cancelAnimationFrame(animationRef.current);
            }
            return () => cancelAnimationFrame(animationRef.current);
          }, [simState.isRunning, simState.speedMultiplier]);


          const formatTime = (mins) => {
            const h = Math.floor(mins / 60);
            const m = Math.floor(mins % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
          };

          const avgWait = simState.stats.delivered === 0 ? 0 : (simState.stats.totalWaitTime / simState.stats.delivered).toFixed(1);

          const getPassengerColor = (p) => {
            const wait = simState.time - p.spawnTime;
            if (wait > 10) return 'bg-red-500';
            if (wait > 5) return 'bg-amber-500';
            return 'bg-blue-500';
          };

          return (
            <div className="min-h-screen bg-slate-100 p-4 font-sans text-slate-800 flex flex-col md:flex-row gap-4 overflow-hidden">
              
              {/* SIDEBAR */}
              <div className="w-full md:w-80 flex flex-col gap-4 shrink-0 h-[calc(100vh-2rem)] overflow-y-auto">
                <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200">
                  <h1 className="text-xl font-bold flex items-center gap-2 text-indigo-600">
                    <Building className="w-6 h-6" /> LiftSim Pro 3.0
                  </h1>
                  <p className="text-xs text-slate-500 mt-1">High-Performance Physics Engine</p>
                </div>

                <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex flex-col gap-4">
                  <div className="flex items-center justify-between bg-slate-50 p-3 rounded-lg">
                    <div className="text-2xl font-mono font-bold text-slate-700">{formatTime(simState.time)}</div>
                    <div className="flex gap-2">
                      {!simState.isRunning ? (
                        <button onClick={() => setSimState(s => ({...s, isRunning: true}))} className="p-2 bg-green-500 text-white rounded hover:bg-green-600"><Play size={20} /></button>
                      ) : (
                        <button onClick={() => setSimState(s => ({...s, isRunning: false}))} className="p-2 bg-amber-500 text-white rounded hover:bg-amber-600"><Pause size={20} /></button>
                      )}
                      <button onClick={initSimulation} className="p-2 bg-slate-200 text-slate-600 rounded hover:bg-slate-300"><RotateCcw size={20} /></button>
                    </div>
                  </div>
                  
                  <div>
                    <label className="text-xs font-semibold text-slate-500 uppercase">Sim Speed (x{simState.speedMultiplier})</label>
                    <input 
                      type="range" min="1" max="1000" 
                      value={simState.speedMultiplier} 
                      onChange={(e) => setSimState(s => ({...s, speedMultiplier: parseInt(e.target.value)}))}
                      className="w-full mt-1 accent-indigo-600"
                    />
                  </div>
                </div>

                <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200">
                  <h2 className="text-sm font-bold text-slate-700 flex items-center gap-2 mb-3">
                    <Activity size={16} /> Real-time Stats
                  </h2>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="p-3 bg-indigo-50 rounded-lg">
                      <div className="text-xs text-indigo-600 uppercase font-bold">Avg Wait</div>
                      <div className="text-2xl font-bold text-indigo-900">{avgWait}<span className="text-sm font-normal">m</span></div>
                    </div>
                    <div className="p-3 bg-indigo-50 rounded-lg">
                      <div className="text-xs text-indigo-600 uppercase font-bold">Max Wait</div>
                      <div className="text-2xl font-bold text-indigo-900">{Math.round(simState.stats.maxWaitTime)}<span className="text-sm font-normal">m</span></div>
                    </div>
                    <div className="p-3 bg-slate-50 rounded-lg col-span-2">
                      <div className="text-xs text-slate-500 uppercase font-bold">Delivered</div>
                      <div className="text-2xl font-bold text-slate-700">{simState.stats.delivered}</div>
                    </div>
                  </div>
                </div>

                <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex-1">
                  <h2 className="text-sm font-bold text-slate-700 flex items-center gap-2 mb-3">
                    <Settings size={16} /> Configuration
                  </h2>
                  
                  <div className="space-y-4">
                    <div>
                      <label className="block text-xs font-medium text-slate-500 mb-1">Building Type</label>
                      <div className="flex bg-slate-100 p-1 rounded-lg">
                        {['residential', 'office'].map(t => (
                          <button 
                            key={t}
                            onClick={() => setConfig(prev => ({...prev, buildingType: t}))}
                            className={`flex-1 py-1 text-xs capitalize rounded-md transition-colors ${config.buildingType === t ? 'bg-white shadow text-indigo-600 font-bold' : 'text-slate-500'}`}
                          >
                            {t}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <label className="block text-xs font-medium text-slate-500 mb-1">Idle Algorithm</label>
                      <select 
                        value={config.idleAlgo} 
                        onChange={(e) => setConfig(prev => ({...prev, idleAlgo: e.target.value}))}
                        className="w-full p-2 bg-slate-50 border border-slate-200 rounded text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      >
                        <option value="stay">Stay Last Position (Weighted)</option>
                        <option value="return_ground">Return to Ground</option>
                        <option value="return_dist">Distributed Staging</option>
                        <option value="ai">Smart Predictive (AI)</option>
                      </select>
                    </div>

                    <div className="grid grid-cols-2 gap-2">
                      <div>
                        <label className="block text-xs font-medium text-slate-500 mb-1">Floors ({config.floors})</label>
                        <input type="range" min="3" max="30" value={config.floors} onChange={e => setConfig(prev => ({...prev, floors: parseInt(e.target.value)}))} className="w-full accent-indigo-600"/>
                      </div>
                      <div>
                        <label className="block text-xs font-medium text-slate-500 mb-1">Lifts ({config.lifts})</label>
                        <input type="range" min="1" max="8" value={config.lifts} onChange={e => setConfig(prev => ({...prev, lifts: parseInt(e.target.value)}))} className="w-full accent-indigo-600"/>
                      </div>
                    </div>

                     <div>
                        <label className="block text-xs font-medium text-slate-500 mb-1">Population / Floor ({config.avgResidentsPerFloor})</label>
                        <input type="range" min="5" max="100" value={config.avgResidentsPerFloor} onChange={e => setConfig(prev => ({...prev, avgResidentsPerFloor: parseInt(e.target.value)}))} className="w-full accent-indigo-600"/>
                      </div>
                  </div>
                </div>
              </div>

              {/* MAIN VIEW */}
              <div className="flex-1 bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col relative">
                <div className="p-3 border-b border-slate-100 flex justify-between items-center bg-slate-50">
                   <span className="text-xs font-bold text-slate-500 uppercase">Building View</span>
                   <div className="flex gap-4 text-xs text-slate-400">
                     <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-blue-500"></span> Normal</span>
                     <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-amber-500"></span> 5m+</span>
                     <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-red-500"></span> 10m+</span>
                   </div>
                </div>

                <div className="flex-1 overflow-y-auto relative bg-slate-100 p-8 flex justify-center">
                    
                    <div className="relative bg-white shadow-xl border-x-4 border-slate-300 transition-all duration-300" 
                         style={{ 
                            width: `${config.lifts * 60 + 100}px`, 
                            height: `${config.floors * FLOOR_HEIGHT_PX}px` 
                         }}>
                      
                      {/* Floors */}
                      {Array.from({ length: config.floors }).map((_, i) => {
                          const floorNum = config.floors - 1 - i;
                          return (
                            <div key={i} 
                                 className="absolute w-full border-b border-slate-200 flex items-center justify-between px-2 text-xs text-slate-400 font-mono"
                                 style={{ 
                                     height: `${FLOOR_HEIGHT_PX}px`, 
                                     top: `${i * FLOOR_HEIGHT_PX}px` 
                                 }}>
                                 <span className="font-bold">{floorNum === 0 ? 'G' : floorNum}</span>
                                 <div className="flex gap-0.5 absolute left-10 flex-wrap max-w-[80px]">
                                    {simState.passengers.filter(p => p.state === 'WAITING' && p.from === floorNum).map((p, idx) => (
                                        <div key={p.id} className={`w-1.5 h-3 rounded-full opacity-80 ${getPassengerColor(p)}`} />
                                    ))}
                                 </div>
                            </div>
                          );
                      })}

                      {/* Lift Shafts */}
                      <div className="absolute inset-0 flex justify-center gap-4 px-12 pointer-events-none">
                         {simState.lifts.map((lift, idx) => {
                             const bottomPos = lift.floor * FLOOR_HEIGHT_PX;
                             return (
                                 <div key={lift.id} className="relative w-12 bg-slate-100 h-full border-x border-dashed border-slate-200/50">
                                     <div 
                                        className={`absolute w-12 h-9 rounded border border-black/10 shadow-sm flex items-center justify-center text-[10px] text-white font-bold z-10
                                            ${lift.state === 'DOOR_OPEN' || lift.state === 'DOOR_CLOSE' ? 'bg-red-500' : 'bg-green-600'}
                                            ${lift.state === 'IDLE' ? 'bg-slate-500' : ''}
                                        `}
                                        style={{ 
                                            bottom: `${bottomPos}px`,
                                            transition: 'bottom 0.1s linear' 
                                        }}
                                     >
                                        <div className="flex flex-col items-center leading-none">
                                          <span className="text-[9px] opacity-80 mb-0.5">L{lift.id + 1}</span>
                                          <div className="flex items-center gap-1">
                                              <span>{lift.passengers.length}</span>
                                              {lift.direction === 1 && <ArrowUp size={8} />}
                                              {lift.direction === -1 && <ArrowDown size={8} />}
                                          </div>
                                        </div>
                                     </div>
                                 </div>
                             );
                         })}
                      </div>

                    </div>
                </div>
              </div>
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ElevatorSimulator />);
    </script>
</body>
</html>
